Document Management Service
REST API сервис для управления жизненным циклом документов.

Стек технологий
Java 17, Spring Boot 3

PostgreSQL (Docker Compose)

Spring Data JPA / Hibernate

Liquibase (миграции БД)

Maven

Запуск проекта
Поднять базу данных:
В корне проекта выполните команду:

Bash
docker-compose up -d
Запустить сервис:
Запустите класс Main.java через IDE или используйте Maven:

Bash
mvn spring-boot:run
При старте Liquibase автоматически создаст схему БД и нужные индексы.

Запуск утилиты генерации
Для массового создания документов используется встроенная утилита.

В корне проекта лежит файл generator.properties. В нем можно указать количество документов (generator.count=50).

Запустите метод main в классе example.docs.util.DocumentGeneratorUtil.

Утилита отправит POST-запросы к API, прогресс будет выведен в консоль.

Фоновая обработка (Workers)
Сервис использует @Scheduled воркеры для фонового перевода статусов (DRAFT -> SUBMITTED -> APPROVED).
Они просыпаются каждые 5 секунд, берут документы пачками (по умолчанию 10 шт.) и обрабатывают их. Прогресс и время выполнения логируются в консоль приложения.

Архитектурные решения (Ответы на вопросы ТЗ)
1. Конкурентное утверждение (Optimistic Locking)
   Реализовано через механизм Optimistic Locking (@Version в сущности Document). При параллельном доступе первый поток успешно фиксирует изменения, остальные получают ObjectOptimisticLockingFailureException и статус документа переводится в CONFLICT.

2. Атомарность пакетной обработки
   Метод обработки одного документа вынесен в компонент DocumentProcessor с аннотацией @Transactional(propagation = Propagation.REQUIRES_NEW). Это гарантирует, что ошибка при утверждении одного документа (например, нарушение уникальности) не откатит всю пачку.

3. Масштабирование пакетной обработки до 5000+ ID
   Передача 5000 ID в одном HTTP-запросе заблокирует поток.
   Решение: Использовать асинхронный подход. API принимает список ID, сохраняет задачу в БД или отправляет в Message Broker (RabbitMQ/Kafka) и возвращает HTTP 202 Accepted. Консьюмеры читают очередь, разбивают 5000 ID на мелкие чанки и обрабатывают параллельно.

4. Вынос Реестра во внешнюю систему
   Если реестр станет отдельным сервисом, распределенная транзакция в монолите перестанет работать.
   Решение: Паттерн Transactional Outbox.
   Вместо прямого вызова внешнего сервиса, мы в локальной транзакции сохраняем событие в таблицу outbox_events. Отдельный Worker надежно читает эту таблицу и отправляет запросы во внешний сервис с механизмом Retry. Это гарантирует Eventual Consistency (согласованность в конечном счете).